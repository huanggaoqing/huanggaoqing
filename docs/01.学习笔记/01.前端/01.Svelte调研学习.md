---
title: Svelte调研学习
date: 2021-11-02 09:51:37
permalink: /pages/a61298/
categories:
  - 学习笔记
  - 前端
tags:
  - JavaScript
  - Svelte
author: huanggaoqing
---
## 结论
生态整体还比较全面，由于发展时间较短所以生态并不够完备。社区目前也比较小，没有像vue，react的社区那么活跃。目前也还没有大型的项目做实践和检验，所以在大而复杂的项目上的使用还是有待考究的。
目前还是属于小而美的类型，构建复杂项目可能会有压力，但用来做一些小的项目还是没有问题的，可以参考携程[https://cloud.tencent.com/developer/article/2016624](https://cloud.tencent.com/developer/article/2016624)，他就是用了svelte做了简单的营销页面。
因为没有runtime的原因，svelte也特别适合开发可独立分发的 web component，使用svelte来发web component的话相比于原生更加易于维护，毕竟可以避免很多的dom操作
## 周边生态
### 路由
[svelte-routing](https://github.com/EmilTholin/svelte-routing) 偏react-router风格 -> 1.9k Star
[svelte-spa-router](https://github.com/ItalyPaleAle/svelte-spa-router) 偏向于vue-router风格 -> 1.4k Star
### 全局状态管理
[svelte_store](https://www.svelte.cn/docs#svelte_store) svelte 框架中自己实现了store，无需安装单独的状态管理库
### SSR
[svelteKit](https://kit.svelte.dev/docs/routing) 目前官方主推的 ssr 框架 -> 16k Star
### 跨平台
[svelte native](https://svelte-native.technology/) 社区提供的native开发库 -> 1.6k Star
桌面应用可以和 electron 结合开发
### **组件库**
[Svelte Material UI](https://sveltematerialui.com/) 扁平化设计，偏向 google 的 UI 设计系统 -> 3.1k Star
[smelte](https://smeltejs.com/) material 的另一种方案 -> 1.5k Star
### 3D可视化
[svelte-cubed](https://svelte-cubed.vercel.app/) svelte基于Three.js的组件库 -> 1.2k Star
### 动画
svelte的动画可以使用官方提供的[动画模块](https://svelte.dev/docs/svelte-motion)
## 优点
### 语法简单
实现同样的一个计数器demo，sevlte的语法明显更加简单、直观，相对于vue和react的语法，svelte的语法少了很多黑魔法。
svelte：
![code.png](https://cdn.nlark.com/yuque/0/2023/png/1663568/1694500664081-e9b0eb9d-ccfe-4000-83c0-234126268de1.png#averageHue=%23767850&clientId=u9aca57ce-9a80-4&from=paste&height=344&id=u29e3bdae&originHeight=688&originWidth=820&originalType=binary&ratio=2&rotation=0&showTitle=false&size=92528&status=done&style=none&taskId=u4652e8e6-f177-4c56-9df7-24780ad5ef6&title=&width=410)
vue：
![vue.png](https://cdn.nlark.com/yuque/0/2023/png/1663568/1694500955137-6b746fde-f5ab-4332-aa7c-c547337d2258.png#averageHue=%23807451&clientId=u9aca57ce-9a80-4&from=paste&height=344&id=uf3a72c53&originHeight=688&originWidth=1356&originalType=binary&ratio=2&rotation=0&showTitle=false&size=120420&status=done&style=none&taskId=ue93564b7-4512-4a99-90eb-4dde82a37bd&title=&width=678)
react：
![react.png](https://cdn.nlark.com/yuque/0/2023/png/1663568/1694501110121-cc184090-10c6-4405-8567-b1033e7a6b56.png#averageHue=%237b714f&clientId=u9aca57ce-9a80-4&from=paste&height=380&id=u482c2fca&originHeight=760&originWidth=1374&originalType=binary&ratio=2&rotation=0&showTitle=false&size=121196&status=done&style=none&taskId=u94b73217-dac1-45d0-9736-2ffc1c4e473&title=&width=687)
### 通过静态编译尽量减少runtime
举例来说，svelte是将模板编译成命令时的原生dom操作，所以自然就不需要在运行时去做虚拟dom的 diff/patch操作了。
但是组件里的if/else，循环逻辑，这些还是需要在运行时去做的。使用到了就会编译进去，没用到就不会编译进去。
所以svelte时通过静态编译尽量减少了runtime，而不能够完全的避免runtime
### 无虚拟dom
虚拟dom比较快，其实一直都是一个误解，虚拟dom只是原生dom的映射，用来做diff算法，相对于原生dom操作的话，虚拟dom反而多了一层对比操作，最终在使用原生方法去操作或者更新dom。因为原生dom的操作心智负担很大，成本很高，需要很高的水平才能做到把性能优化到极致，所以有了虚拟dom和diff算法，他们两个的组合本质上是为了普适性，降低了下限。不管开发者的水平如何，不管怎么写性能上也说的过去。
svelte则是去掉了虚拟dom，它是为每个组件创建一个组件实例，组件变化时会产生新的实例，最终通过对比新旧实例中的dom树实现更新，svelte使用diff算法实在传统虚拟dom的diff算法上做了优化：

- 使用key标记DOM
- 合并DOM（移位算法）、减少DOM
- 缓存DPOM（可变长缓存）

## Svelte和Vue、React的对比
| 指标 | Svelte | Vue | React |
| --- | --- | --- | --- |
| 大小 | ~ 4 KB | ~ 21 KB | ~ 43 KB |
| 学习曲线 | 简单 | 中等 | 中等 |
| 模板语法 | Svelte特有 | Vue特有 | JSX |
| 状态管理 | svelte_store | Vuex | Redux |
| 生态系统 | 较小 | 巨大 | 巨大 |
| 性能 | 高 | 高 | 一般 |
| 体积 | 最小 | 较小 | 较大 |
| 虚拟 DOM | 无 | 有 | 有 |
| 核心概念 | 编译时优化 | 响应式系统、模板 | 组件化、状态管理 |
| 社区支持 | 较小 | 大 | 最大 |

