---
title: Electron WebView
date: 2023-10-15 00:50:32
permalink: /pages/0c2d6d/
categories:
  - 学习笔记
  - 前端
tags:
  - Electron
  - TypeScript
  - webView
author: 
  name: huanggaoqing
  link: https://github.com/huanggaoqing
---
## webview 初始化
Electron >5 默认禁用 webview, 所以使用时需要先配置启用 webviewTag.
```typescript
 const mainWindow = new BrowserWindow({
  width: 900,
  height: 670,
  show: false,
  autoHideMenuBar: true,
  ...(process.platform === 'linux' ? { icon } : {}),
  webPreferences: {
    preload: join(__dirname, '../preload/index.js'),
    sandbox: false,
    webviewTag: true, // 使用 webview 时开启
  }
})
```
在指定位置渲染 webview
```vue
<script setup lang="ts">
import { onMounted, ref } from "vue";
  
const webviewController = ref()
onMounted(() => {
  webviewController.value?.addEventListener("dom-ready", async () => {
    webviewController.value?.openDevTools()
  })
})
</script>

<template>
  <div>
    <webview
      ref="webviewController"
      id="foo"
      src="https://www.baidu.com/"
      style="display:inline-flex; width:750px; height: calc(100vh - 5px)"
    >
    </webview>
  </div>
</template>

<style scoped></style>

```
## webview 通信
使用webview的preload将ipcrender注入到webview中
### 注入通信方法
preload暴露方法给webview
```typescript
import { ipcRenderer, contextBridge } from "electron"

// 暴露方法给webview
contextBridge.exposeInMainWorld('$native', {
  send(event:string, args: any) {
    ipcRenderer.sendToHost(event, args)
  },
  on(event: string, callback: any) {
    ipcRenderer.on(event, callback)
  }
})
```
主进程中保存preload文件路径
```typescript
  // 获取本地 preload.js 文件的路径
  const preloadPath = path.join(__dirname, "preload.js");
  global.shareObject = {
    webviewPreload: path.join(__dirname, "preload.js")
  }
```
渲染进程获取路径并设置给webview的preload
webview 的 preload 属性只支持 `file: `和`asar:`协议
```vue
<script setup lang="ts">
import { onMounted, ref } from "vue";
import * as remote from "@electron/remote"

const webviewController = ref()
onMounted(() => {
  console.log(remote.getGlobal('shareObject').webviewPreload)
  webviewController.value?.addEventListener("dom-ready", async () => {
    webviewController.value?.openDevTools()
  })
})
</script>

<template>
  <div>
    <webview
      ref="webviewController"
      id="foo"
      src="https://www.baidu.com/"
      style="display:inline-flex; width:750px; height: calc(100vh - 5px)"
      :preload="remote.getGlobal('shareObject').webviewPreload"
    >
    </webview>
  </div>
</template>

<style scoped></style>
```
### 通信调用
native
```typescript
// 接收 webview 发送的消息
webviewController.value?.addEventListener('ipc-message', handleWebviewMessage)
function handleWebviewMessage({channel, args}: any) {
  console.log({channel, args})
  if (channel === "PING") {
    // 向 webview 发送消息
    webviewController.value?.send("PONG", {channel: "native"})
  }
}
```
webview
```typescript
// 向 native 发送消息
$native.send("PING", "webview")
// 接受 native 消息
$sendToHost.on("PONG", (e, msg) => {
    console.log(msg)
})
```
## webview 注入
### 注入js

1. 使用preload注入js代码，参考 `注入通信方法`
2. 使用`executeJavaScript`执行webview中的js方法

native 调用方法
```typescript
async function getInfo(): Promise<void> {
  info.value = await webviewController.value.executeJavaScript("getInfo()")
  console.log({info: info.value})
}
```
webview 声明方法
```typescript
window.getInfo = () => {
    return {
        name: "webview",
        desc: "这是一个webview"
    }
}
```
### 注入css方法
```typescript
function injectCssToWebview(): void {
  webviewController.value.insertCSS(`
    .mnav{
      color: red !important;
    }
  `)
}
```
## demo参考
[https://github.com/huanggaoqing/electron_webview](https://github.com/huanggaoqing/electron_webview)
